#!/usr/bin/env node
"use strict";

// Single-file CLI that controls Google Chrome via the Chrome DevTools Protocol (CDP).
// - NO Playwright dependency. Chrome is the main driver.
// - One script acts as both client and server. The server is auto-started on demand.
// - Each "session" launches its own Chrome with a dedicated user-data-dir and remote-debugging-port.
// - Commands: session create/ls/info/close, goto, click, type, fill, press, wait-for, dom, text, attr, screenshot, pdf, cookies, storage, eval, eval-file, status, shutdown.
//
// Auto-detects Chrome installation on macOS, Windows, and Linux.
// Requires: Node >= 18 and npm package 'ws' (WebSocket). Install with: npm i -D ws

const fs = require("node:fs");
const os = require("node:os");
const path = require("node:path");
const http = require("node:http");
const net = require("node:net");
const cp = require("node:child_process");
const { setTimeout: delay } = require("node:timers/promises");
const WebSocket = require("ws");

////////////////////////////////////////////////////////////////////////////////
// Config
////////////////////////////////////////////////////////////////////////////////
function getChromePath() {
  const platform = process.platform;
  
  if (platform === "darwin") {
    return "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome";
  } else if (platform === "win32") {
    // Common Windows paths for Chrome
    const windowsPaths = [
      process.env.LOCALAPPDATA + "\\Google\\Chrome\\Application\\chrome.exe",
      process.env.PROGRAMFILES + "\\Google\\Chrome\\Application\\chrome.exe",
      process.env["PROGRAMFILES(X86)"] + "\\Google\\Chrome\\Application\\chrome.exe"
    ];
    
    for (const chromeExePath of windowsPaths) {
      try {
        if (fs.existsSync(chromeExePath)) {
          return chromeExePath;
        }
      } catch {}
    }
    
    // Fallback to PATH
    return "chrome.exe";
  } else {
    // Linux and other Unix-like systems
    const linuxPaths = [
      "/usr/bin/google-chrome",
      "/usr/bin/google-chrome-stable",
      "/usr/bin/chromium",
      "/usr/bin/chromium-browser",
      "/snap/bin/chromium",
      "/opt/google/chrome/chrome"
    ];
    
    for (const chromePath of linuxPaths) {
      try {
        if (fs.existsSync(chromePath)) {
          return chromePath;
        }
      } catch {}
    }
    
    // Fallback to PATH
    return "google-chrome";
  }
}

////////////////////////////////////////////////////////////////////////////////
// Tiny arg parsing
////////////////////////////////////////////////////////////////////////////////
function parseArgv(argv) {
  const flags = {};
  const rest = [];
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a.startsWith("--")) {
      const eq = a.indexOf("=");
      if (eq !== -1) {
        const k = a.slice(2, eq);
        const v = a.slice(eq + 1);
        flags[k] = v === "true" ? true : v === "false" ? false : v;
      } else {
        const k = a.slice(2);
        const next = argv[i + 1];
        if (next && !next.startsWith("--")) {
          flags[k] = next;
          i++;
        } else {
          flags[k] = true;
        }
      }
    } else {
      rest.push(a);
    }
  }
  return { flags, rest };
}

////////////////////////////////////////////////////////////////////////////////
// Endpoint helpers (UDS by default on POSIX; named pipe on Windows; TCP if given)
////////////////////////////////////////////////////////////////////////////////
function ensureDir(p) {
  try { fs.mkdirSync(p, { recursive: true }); } catch { /* noop */ }
}

function defaultSocketPath() {
  const dir = path.join(os.homedir(), ".cache");
  ensureDir(dir);
  return path.join(dir, "playd.sock");
}

function defaultPipeNameWin() {
  return "\\\\.\\pipe\\playd"; // Windows named pipe
}

function getEndpoint(flags) {
  // If host/port provided, use TCP.
  if (flags.host || flags.port) {
    const host = flags.host || "127.0.0.1";
    const port = Number(flags.port || 3210);
    return { type: "tcp", host, port };
  }
  // Otherwise prefer a local socket/pipe, but use TCP on Windows for better CI compatibility.
  if (process.platform === "win32") {
    // Use TCP on Windows for better compatibility in CI environments
    return { type: "tcp", host: "127.0.0.1", port: 3210 };
  }
  return { type: "uds", socket: flags.socket || defaultSocketPath() };
}

function endpointToString(ep) {
  if (ep.type === "tcp") return `tcp://${ep.host}:${ep.port}`;
  if (ep.type === "pipe") return `pipe:${ep.pipe}`;
  return `socket:${ep.socket}`;
}

////////////////////////////////////////////////////////////////////////////////
// HTTP client over UDS / named pipe / TCP
////////////////////////////////////////////////////////////////////////////////
function httpRequest(ep, method, urlPath, body, { timeout = 30000 } = {}) {
  const headers = { "content-type": "application/json" };
  const payload = body == null ? null : JSON.stringify(body);
  if (payload) headers["content-length"] = Buffer.byteLength(payload);

  return new Promise((resolve, reject) => {
    let opts;
    if (ep.type === "tcp") {
      opts = { method, host: ep.host, port: ep.port, path: urlPath, headers, timeout };
    } else if (ep.type === "uds") {
      opts = { method, socketPath: ep.socket, path: urlPath, headers, timeout };
    } else if (ep.type === "pipe") {
      // Node supports named pipes via socketPath as well
      opts = { method, socketPath: ep.pipe, path: urlPath, headers, timeout };
    } else {
      return reject(new Error("Unknown endpoint type"));
    }

    const req = http.request(opts, (res) => {
      const chunks = [];
      res.on("data", (d) => chunks.push(d));
      res.on("end", () => {
        const raw = Buffer.concat(chunks).toString("utf8");
        if ((res.headers["content-type"] || "").includes("application/json")) {
          try {
            const json = raw ? JSON.parse(raw) : {};
            resolve({ statusCode: res.statusCode || 0, headers: res.headers, body: json });
          } catch (e) {
            resolve({ statusCode: res.statusCode || 0, headers: res.headers, body: raw });
          }
        } else {
          resolve({ statusCode: res.statusCode || 0, headers: res.headers, body: raw });
        }
      });
    });
    req.on("error", reject);
    if (timeout) req.setTimeout(timeout, () => req.destroy(new Error("Request timeout")));
    if (payload) req.write(payload);
    req.end();
  });
}

async function serverReachable(ep, timeoutMs = 1500) {
  try {
    const res = await httpRequest(ep, "GET", "/health", null, { timeout: timeoutMs });
    return res.statusCode === 200;
  } catch {
    return false;
  }
}

function spawnServer(ep) {
  const args = [__filename, "--server", `--endpoint=${encodeURIComponent(JSON.stringify(ep))}`];
  const child = cp.spawn(process.execPath, args, {
    detached: true,
    stdio: "ignore",
  });
  child.unref();
}

async function ensureServer(ep, waitTimeout = 8000) {
  if (await serverReachable(ep)) return true;
  spawnServer(ep);
  const start = Date.now();
  while (Date.now() - start < waitTimeout) {
    await delay(150);
    if (await serverReachable(ep)) return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////
// Output helpers
////////////////////////////////////////////////////////////////////////////////
function print(obj, jsonMode) {
  if (jsonMode) {
    process.stdout.write(JSON.stringify(obj, null, 2) + "\n");
  } else if (typeof obj === "string") {
    process.stdout.write(obj + "\n");
  } else {
    process.stdout.write((obj && obj.message) ? obj.message + "\n" : JSON.stringify(obj) + "\n");
  }
}

function err(s) {
  process.stderr.write(s + "\n");
}

function serverLog(msg) {
  const fs = require("fs");
  const timestamp = new Date().toISOString();
  fs.appendFileSync("server.log", `[${timestamp}] ${msg}\n`);
}

////////////////////////////////////////////////////////////////////////////////
// Minimal CDP client
////////////////////////////////////////////////////////////////////////////////
class CDP {
  constructor(wsUrl) {
    this.wsUrl = wsUrl;
    this.ws = null;
    this.id = 0;
    this.pending = new Map();
    this.eventHandlers = new Map();
  }
  async connect() {
    this.ws = new WebSocket(this.wsUrl);
    await new Promise((resolve, reject) => {
      this.ws.once("open", resolve);
      this.ws.once("error", reject);
    });
    this.ws.on("message", (data) => {
      try {
        const msg = JSON.parse(String(data));
        if (msg.id && this.pending.has(msg.id)) {
          const { resolve, reject } = this.pending.get(msg.id);
          this.pending.delete(msg.id);
          if (msg.error) reject(new Error(msg.error.message || String(msg.error)));
          else resolve(msg.result);
        } else if (msg.method) {
          const cb = this.eventHandlers.get(msg.method);
          if (cb) cb(msg.params);
        }
      } catch {}
    });
  }
  on(method, cb) { this.eventHandlers.set(method, cb); }
  send(method, params = {}) {
    const id = ++this.id;
    const payload = JSON.stringify({ id, method, params });
    return new Promise((resolve, reject) => {
      this.pending.set(id, { resolve, reject });
      this.ws.send(payload, (err) => { if (err) { this.pending.delete(id); reject(err); } });
    });
  }
  close() { try { this.ws && this.ws.close(); } catch {} }
}

////////////////////////////////////////////////////////////////////////////////
// Chrome session management
////////////////////////////////////////////////////////////////////////////////
async function findFreePort() {
  return new Promise((resolve, reject) => {
    const s = net.createServer();
    s.listen(0, () => {
      const { port } = s.address();
      s.close(() => resolve(port));
    });
    s.on("error", reject);
  });
}

async function waitForJson(url, timeoutMs = 8000) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    try {
      const res = await fetch(url);
      if (res.ok) return await res.json();
    } catch {}
    await delay(150);
  }
  throw new Error(`Timeout waiting for ${url}`);
}

async function openNewPageWs(port, url = "about:blank") {
  const res = await fetch(`http://127.0.0.1:${port}/json/new?${encodeURIComponent(url)}`, { method: 'PUT' });
  if (!res.ok) throw new Error("Failed to create new target");
  const info = await res.json();
  return info.webSocketDebuggerUrl;
}

////////////////////////////////////////////////////////////////////////////////
// Client command handlers
////////////////////////////////////////////////////////////////////////////////
async function clientMain(flags, rest) {
  const jsonMode = !!flags.json;
  const ep = getEndpoint(flags);
  const cmd = rest[0];
  const a1 = rest[1];
  const a2 = rest[2];

  async function needSession() {
    let sid = flags.session || process.env.PLAYD_SESSION;
    if (!sid) {
      // Try to get the most recent session from the server
      try {
        const response = await call("GET", "/session/ls");
        if (response.sessions && response.sessions.length > 0) {
          // Use the most recently active session (smallest ageSec = most recent)
          const sortedSessions = response.sessions.sort((a, b) => a.ageSec - b.ageSec);
          sid = sortedSessions[0].id;
        }
      } catch {}
    }
    if (!sid) { 
      err("No session specified. Use --session <id>, set PLAYD_SESSION, or create a session first."); 
      process.exit(2); 
    }
    return sid;
  }

  async function call(method, url, body) {
    const ok = await ensureServer(ep);
    if (!ok) { err(`Failed to start background server at ${endpointToString(ep)}`); process.exit(6); }
    const res = await httpRequest(ep, method, url, body, { timeout: Number(flags.timeout || 30000) });
    if ((res.statusCode || 500) >= 400) {
      if (jsonMode) print({ ok: false, status: res.statusCode, error: res.body && (res.body.error || res.body) }, true);
      else err(`HTTP ${res.statusCode}: ${res.body && (res.body.error || res.body)}`);
      process.exit(1);
    }
    return res.body;
  }

  switch (cmd) {
    case "help":
    case undefined: {
      const text = `playd (CDP)

Usage:
  playd session create <id> [--headed] [--profile <dir>]
  playd session ls
  playd session info <id>
  playd session close <id>

  playd goto <url> [--session <id>] [--waitUntil load|domcontentloaded|networkidle] [--timeout 30000]
  playd click <selector> [--session <id>]
  playd type <text> [--session <id>] [--selector <sel>] [--delay 20] [--clear]
  playd fill <selector> <text> [--session <id>]
  playd press <key> [--session <id>] [--selector <sel>]
  playd wait-for <selector> [--session <id>] [--state visible|attached|hidden|detached] [--timeout 30000]
  playd sleep <ms>

  playd dom [--session <id>] [--pretty]
  playd text [--session <id>] [--selector <sel>]
  playd attr <selector> <name> [--session <id>]
  playd screenshot [--session <id>] [--path out.png] [--full-page]
  playd pdf [--session <id>] [--path out.pdf] [--format A4] [--margin 10]
  playd cookies [--session <id>] [--set file.json]
  playd cookie-get <name> [--session <id>]
  playd cookie-set <name> <value> [--session <id>] [--domain <domain>] [--path <path>]
  playd storage [--session <id>] [--export file.json] [--import file.json]
  playd eval '<js>' [--session <id>]
  playd eval-file ./snippet.js [--session <id>]
  playd llm '<question>' [--session <id>] [--on-html]

  playd status
  playd shutdown
`;
      print(text, false);
      return;
    }

    case "status": {
      const body = await call("GET", "/status");
      print(body, jsonMode);
      return;
    }

    case "shutdown": {
      const body = await call("POST", "/shutdown");
      print(body, jsonMode);
      return;
    }

    case "session": {
      const sub = rest[1];
      if (sub === "create") {
        const id = rest[2];
        if (!id) { err("Usage: playd session create <id>"); process.exit(2); }
        const headed = !!flags.headed;
        const profile = flags.profile || null;
        const body = await call("POST", "/session/create", { id, headed, profile });
        print(body, jsonMode);
        return;
      }
      if (sub === "ls") {
        const body = await call("GET", "/session/ls");
        if (jsonMode) return print(body, true);
        if (!body.sessions || body.sessions.length === 0) return print("(no sessions)");
        body.sessions.forEach(s => { print(`${s.id}  url=${s.url}  port=${s.port}  age=${Math.round(s.ageSec)}s`, false); });
        return;
      }
      if (sub === "info") {
        const id = rest[2];
        if (!id) { err("Usage: playd session info <id>"); process.exit(2); }
        const body = await call("GET", `/session/info?id=${encodeURIComponent(id)}`);
        print(body, jsonMode);
        return;
      }
      if (sub === "close") {
        const id = rest[2];
        if (!id) { err("Usage: playd session close <id>"); process.exit(2); }
        const body = await call("DELETE", `/session/close?id=${encodeURIComponent(id)}`);
        print(body, jsonMode);
        return;
      }
      err("Unknown: playd session <create|ls|info|close>");
      process.exit(2);
    }

    case "goto": {
      const id = await needSession();
      const url = a1; if (!url) { err("Usage: playd goto <url>"); process.exit(2); }
      const waitUntil = flags.waitUntil || "load";
      const timeout = Number(flags.timeout || 30000);
      const body = await call("POST", "/goto", { id, url, waitUntil, timeout });
      print(body, jsonMode);
      return;
    }

    case "click": {
      const id = await needSession();
      const selector = a1; if (!selector) { err("Usage: playd click <selector>"); process.exit(2); }
      const timeout = Number(flags.timeout || 30000);
      const body = await call("POST", "/click", { id, selector, timeout });
      print(body, jsonMode);
      return;
    }

    case "type": {
      const id = await needSession();
      const selector = flags.selector || null;
      const text = a1;
      if (text == null) { err("Usage: playd type <text> [--selector <sel>] [--delay 20] [--clear]"); process.exit(2); }
      const delayMs = Number(flags.delay || 0);
      const clear = !!flags.clear;
      const timeout = Number(flags.timeout || 30000);
      const body = await call("POST", "/type", { id, selector, text, delay: delayMs, clear, timeout });
      print(body, jsonMode);
      return;
    }

    case "fill": {
      const id = await needSession();
      const selector = a1; const text = a2;
      if (!selector || text == null) { err("Usage: playd fill <selector> <text>"); process.exit(2); }
      const timeout = Number(flags.timeout || 30000);
      const body = await call("POST", "/fill", { id, selector, text, timeout });
      print(body, jsonMode);
      return;
    }

    case "press": {
      const id = await needSession();
      const key = a1; if (!key) { err("Usage: playd press <key> [--selector <sel>]"); process.exit(2); }
      const selector = flags.selector || null;
      const timeout = Number(flags.timeout || 30000);
      const body = await call("POST", "/press", { id, selector, key, timeout });
      print(body, jsonMode);
      return;
    }

    case "wait-for": {
      const id = await needSession();
      const selector = a1; if (!selector) { err("Usage: playd wait-for <selector>"); process.exit(2); }
      const state = flags.state || "visible";
      const timeout = Number(flags.timeout || 30000);
      const body = await call("POST", "/wait-for", { id, selector, state, timeout });
      print(body, jsonMode);
      return;
    }

    case "sleep": {
      const ms = Number(a1 || 1000);
      await delay(ms);
      print({ ok: true, sleptMs: ms }, jsonMode);
      return;
    }

    case "dom":
    case "html": {
      const id = await needSession();
      const pretty = !!flags.pretty;
      const body = await call("GET", `/dom?id=${encodeURIComponent(id)}&prettify=${pretty ? 1 : 0}`);
      if (jsonMode) print(body, true); else process.stdout.write(body.html + "\n");
      return;
    }

    case "text": {
      const id = await needSession();
      const sel = flags.selector || null;
      const body = await call("GET", `/text?id=${encodeURIComponent(id)}${sel ? `&selector=${encodeURIComponent(sel)}` : ""}`);
      if (jsonMode) print(body, true); else process.stdout.write((body.text || "") + "\n");
      return;
    }

    case "attr": {
      const id = await needSession();
      const selector = a1; const name = a2;
      if (!selector || !name) { err("Usage: playd attr <selector> <name>"); process.exit(2); }
      const body = await call("GET", `/attr?id=${encodeURIComponent(id)}&selector=${encodeURIComponent(selector)}&name=${encodeURIComponent(name)}`);
      if (jsonMode) print(body, true); else process.stdout.write(String(body.value ?? "") + "\n");
      return;
    }

    case "screenshot": {
      const id = await needSession();
      let out = flags.path || null; if (out) out = path.resolve(process.cwd(), out);
      const fullPage = !!flags["full-page"];
      const body = await call("POST", "/screenshot", { id, path: out, fullPage });
      if (jsonMode) print(body, true); else print(out ? `wrote ${out}` : `data:${body.mime};base64,${body.base64}`, false);
      return;
    }

    case "pdf": {
      const id = await needSession();
      let out = flags.path || null; if (out) out = path.resolve(process.cwd(), out);
      const format = flags.format || "A4";
      const margin = Number(flags.margin || 10);
      const body = await call("POST", "/pdf", { id, path: out, format, margin });
      if (jsonMode) print(body, true); else print(out ? `wrote ${out}` : `data:application/pdf;base64,${body.base64}`, false);
      return;
    }

    case "cookies": {
      const id = await needSession();
      if (flags.set) {
        const file = path.resolve(process.cwd(), String(flags.set));
        const json = JSON.parse(fs.readFileSync(file, "utf8"));
        const body = await call("POST", "/cookies/set", { id, cookies: json });
        print(body, jsonMode);
      } else {
        const body = await call("GET", `/cookies?id=${encodeURIComponent(id)}`);
        print(body, jsonMode);
      }
      return;
    }

    case "cookie-get": {
      const id = await needSession();
      const name = a1; if (!name) { err("Usage: playd cookie-get <name>"); process.exit(2); }
      const body = await call("GET", `/cookie-get?id=${encodeURIComponent(id)}&name=${encodeURIComponent(name)}`);
      if (jsonMode) print(body, true); else print(body.value || "", false);
      return;
    }

    case "cookie-set": {
      const id = await needSession();
      const name = a1; const value = a2;
      if (!name || value == null) { err("Usage: playd cookie-set <name> <value> [--domain example.com] [--path /]"); process.exit(2); }
      const domain = flags.domain || null;
      const cookiePath = flags.path || "/";
      const body = await call("POST", "/cookie-set", { id, name, value, domain, path: cookiePath });
      print(body, jsonMode);
      return;
    }

    case "storage": {
      const id = await needSession();
      if (flags.export) {
        const body = await call("GET", `/storage/export?id=${encodeURIComponent(id)}`);
        const target = path.resolve(process.cwd(), String(flags.export));
        fs.writeFileSync(target, JSON.stringify(body, null, 2));
        print({ ok: true, path: target }, jsonMode);
      } else if (flags.import) {
        const file = path.resolve(process.cwd(), String(flags.import));
        const json = JSON.parse(fs.readFileSync(file, "utf8"));
        const body = await call("POST", "/storage/import", { id, data: json });
        print(body, jsonMode);
      } else {
        const body = await call("GET", `/storage/export?id=${encodeURIComponent(id)}`);
        print(body, jsonMode);
      }
      return;
    }

    case "eval": {
      const id = await needSession();
      const js = rest.slice(1).join(" ");
      if (!js) { err("Usage: playd eval '<js>'"); process.exit(2); }
      const body = await call("POST", "/eval", { id, code: js });
      if (jsonMode) {
        print(body, true);
      } else {
        if (!body.ok) {
          err(`Error: ${body.error}`);
          process.exit(1);
        } else if (body.hasOwnProperty('result')) {
          if (body.resultType === 'undefined') {
            print('undefined', false);
          } else {
            print(body.result, false);
          }
        } else {
          print(body, false);
        }
      }
      return;
    }

    case "eval-file": {
      const id = await needSession();
      const file = a1; if (!file) { err("Usage: playd eval-file ./snippet.js"); process.exit(2); }
      const js = fs.readFileSync(path.resolve(process.cwd(), file), "utf8");
      const body = await call("POST", "/eval", { id, code: js });
      print(body, jsonMode);
      return;
    }

    case "llm": {
      const id = await needSession();
      const question = rest.slice(1).join(" ");
      if (!question) { err("Usage: playd llm '<question about the page>' [--on-html]"); process.exit(2); }
      const onHtml = !!flags["on-html"];
      const body = await call("POST", "/llm", { id, question, onHtml });
      if (!body.ok) {
        err(`Error: ${body.error}`);
        process.exit(1);
      }
      print(body.answer, false);
      return;
    }

    default:
      err(`Unknown command: ${cmd}. Try 'playd help'.`);
      process.exit(2);
  }
}

////////////////////////////////////////////////////////////////////////////////
// Server implementation (Chrome per session via CDP)
////////////////////////////////////////////////////////////////////////////////
async function serverMain(ep) {
  const sessions = new Map(); // id -> { id, port, chromeProc, wsUrl, cdp, createdAt, lastActive, userDataDir }
  const launchedAt = Date.now();

  async function launchChromeSession(id, { headed = false, profile = null } = {}) {
    if (sessions.has(id)) return sessions.get(id);
    const port = await findFreePort();
    const userDataDir = profile ? path.resolve(profile) : fs.mkdtempSync(path.join(os.tmpdir(), `playd-${id}-`));
    const args = [
      `--remote-debugging-port=${port}`,
      `--user-data-dir=${userDataDir}`,
      "--no-first-run",
      "--no-default-browser-check",
      "--disable-features=TranslateUI",
      "about:blank",
    ];
    if (!headed) args.unshift("--headless=new", "--disable-gpu");

    const chrome = cp.spawn(getChromePath(), args, { stdio: "ignore" });
    chrome.on("exit", () => { /* cleaned elsewhere */ });

    // wait for /json/version to appear
    await waitForJson(`http://127.0.0.1:${port}/json/version`, 10000);

    // use the existing initial tab instead of creating a new one
    const tabsRes = await fetch(`http://127.0.0.1:${port}/json`);
    if (!tabsRes.ok) throw new Error("Failed to get existing tabs");
    const tabs = await tabsRes.json();
    
    // find the first page tab (usually the initial about:blank)
    const initialTab = tabs.find(tab => tab.type === "page");
    let pageWs;
    
    if (!initialTab) {
      // fallback: create new tab if no existing tab found
      pageWs = await openNewPageWs(port, "about:blank");
    } else {
      // use the existing tab
      pageWs = initialTab.webSocketDebuggerUrl;
    }
    
    const cdp = new CDP(pageWs);
    await cdp.connect();

    // enable domains
    await cdp.send("Page.enable");
    await cdp.send("Runtime.enable");
    await cdp.send("DOM.enable");
    await cdp.send("Network.enable");

    const sess = { id, port, chromeProc: chrome, wsUrl: pageWs, cdp, createdAt: Date.now(), lastActive: Date.now(), userDataDir, headed };
    sessions.set(id, sess);
    return sess;
  }

  async function closeSession(id) {
    const s = sessions.get(id);
    if (!s) return false;
    try { s.cdp.close(); } catch {}
    try { s.chromeProc.kill(); } catch {}
    sessions.delete(id);
    return true;
  }

  async function withSession(id) {
    const s = sessions.get(id);
    if (!s) throw new Error("Unknown session");
    s.lastActive = Date.now();
    return s;
  }

  const server = http.createServer((req, res) => {
    handle(req, res).catch((e) => {
      try {
        res.writeHead(500, { "content-type": "application/json" });
        res.end(JSON.stringify({ ok: false, error: String(e && e.message || e) }));
      } catch {}
    });
  });

  async function readJson(req) {
    const chunks = [];
    for await (const c of req) chunks.push(c);
    const raw = Buffer.concat(chunks).toString("utf8");
    return raw ? JSON.parse(raw) : {};
  }

  function reply(res, code, obj) {
    res.writeHead(code, { "content-type": "application/json" });
    res.end(JSON.stringify(obj));
  }

  async function handle(req, res) {
    const url = new URL(req.url, "http://localhost");
    const method = req.method || "GET";

    if (method === "GET" && url.pathname === "/health") return reply(res, 200, { ok: true });

    if (method === "GET" && url.pathname === "/status") {
      const now = Date.now();
      const list = [];
      for (const [id, s] of sessions) {
        let curUrl = "";
        try { const r = await s.cdp.send("Runtime.evaluate", { expression: "location.href", returnByValue: true }); curUrl = r.result.value || ""; } catch {}
        list.push({ id, url: curUrl, port: s.port, headed: s.headed, ageSec: (now - s.createdAt) / 1000 });
      }
      return reply(res, 200, { ok: true, uptimeMs: now - launchedAt, sessions: list });
    }

    if (method === "POST" && url.pathname === "/shutdown") {
      reply(res, 200, { ok: true });
      setTimeout(async () => {
        for (const [id] of sessions) { try { await closeSession(id); } catch {} }
        process.exit(0);
      }, 50);
      return;
    }

    if (method === "POST" && url.pathname === "/session/create") {
      const body = await readJson(req);
      const s = await launchChromeSession(body.id, { headed: !!body.headed, profile: body.profile || null });
      return reply(res, 200, { ok: true, id: s.id, port: s.port, headed: s.headed, userDataDir: s.userDataDir });
    }

    if (method === "GET" && url.pathname === "/session/ls") {
      const now = Date.now();
      const out = [];
      for (const [id, s] of sessions) {
        let curUrl = "";
        try { const r = await s.cdp.send("Runtime.evaluate", { expression: "location.href", returnByValue: true }); curUrl = r.result.value || ""; } catch {}
        out.push({ id, url: curUrl, port: s.port, ageSec: (now - s.createdAt) / 1000 });
      }
      return reply(res, 200, { ok: true, sessions: out });
    }

    if (method === "GET" && url.pathname === "/session/info") {
      const id = url.searchParams.get("id");
      const s = sessions.get(id);
      if (!s) return reply(res, 404, { ok: false, error: "not found" });
      let curUrl = "";
      try { const r = await s.cdp.send("Runtime.evaluate", { expression: "location.href", returnByValue: true }); curUrl = r.result.value || ""; } catch {}
      return reply(res, 200, { ok: true, session: { id, url: curUrl, port: s.port, headed: s.headed, createdAt: s.createdAt, lastActive: s.lastActive } });
    }

    if (method === "DELETE" && url.pathname === "/session/close") {
      const id = url.searchParams.get("id");
      if (!id) return reply(res, 400, { ok: false, error: "Missing id" });
      const ok = await closeSession(id);
      return reply(res, ok ? 200 : 404, { ok });
    }

    if (method === "POST" && url.pathname === "/goto") {
      const { id, url: target, waitUntil = "load", timeout = 30000 } = await readJson(req);
      const s = await withSession(id);
      await s.cdp.send("Page.navigate", { url: target });
      if (waitUntil === "load" || waitUntil === "networkidle") {
        await s.cdp.send("Page.waitForLoadEventFired").catch(()=>{}); // non-standard: will reject; fallback below
      }
      // Fallback wait
      const start = Date.now();
      while (Date.now() - start < timeout) {
        try {
          const st = await s.cdp.send("Page.getNavigationHistory");
          if (st && st.currentIndex >= 0) break;
        } catch {}
        await delay(100);
      }
      return reply(res, 200, { ok: true });
    }

    if (method === "POST" && url.pathname === "/click") {
      const { id, selector, timeout = 30000 } = await readJson(req);
      const s = await withSession(id);
      
      await s.cdp.send("DOM.enable");
      const doc = await s.cdp.send("DOM.getDocument", { depth: 1 });
      
      // Try to find the selector, with 1-second retry if not found
      let q = await s.cdp.send("DOM.querySelector", { nodeId: doc.root.nodeId, selector });
      if (!q.nodeId) {
        serverLog(`Click selector "${selector}" not found, waiting 1 second and retrying...`);
        await delay(1000);
        // Refresh the DOM document in case it changed
        const newDoc = await s.cdp.send("DOM.getDocument", { depth: 1 });
        q = await s.cdp.send("DOM.querySelector", { nodeId: newDoc.root.nodeId, selector });
        if (!q.nodeId) return reply(res, 404, { ok: false, error: "selector not found" });
      }
      
      const box = await s.cdp.send("DOM.getBoxModel", { nodeId: q.nodeId });
      const quad = box.model.content || box.model.border || box.model.margin || box.model.padding;
      const xs = [quad[0], quad[2], quad[4], quad[6]];
      const ys = [quad[1], quad[3], quad[5], quad[7]];
      const x = (Math.min(...xs) + Math.max(...xs)) / 2;
      const y = (Math.min(...ys) + Math.max(...ys)) / 2;
      await s.cdp.send("Input.dispatchMouseEvent", { type: "mousePressed", x, y, button: "left", clickCount: 1 });
      await s.cdp.send("Input.dispatchMouseEvent", { type: "mouseReleased", x, y, button: "left", clickCount: 1 });
      return reply(res, 200, { ok: true });
    }

    if (method === "POST" && url.pathname === "/type") {
      const { id, selector, text, delay: d = 0, clear = false, timeout = 30000 } = await readJson(req);
      serverLog(`/type request: id=${id}, selector=${selector}, text=${text}, delay=${d}, clear=${clear}`);
      const s = await withSession(id);
      
      if (selector) {
        // Focus on the specified selector
        await s.cdp.send("DOM.enable");
        const doc = await s.cdp.send("DOM.getDocument", { depth: 1 });
        const q = await s.cdp.send("DOM.querySelector", { nodeId: doc.root.nodeId, selector });
        if (!q.nodeId) return reply(res, 404, { ok: false, error: "selector not found" });
        await s.cdp.send("DOM.focus", { nodeId: q.nodeId });
      }
      // If no selector provided, type into currently focused element
      
      if (clear) {
        // Clear field by setting value to empty using JavaScript
        const expr = `(() => { const el = document.activeElement; if (el && ('value' in el)) { el.value = ''; el.dispatchEvent(new Event('input', {bubbles:true})); } })()`;
        await s.cdp.send("Runtime.evaluate", { expression: expr });
      }
      for (const ch of String(text)) {
        await s.cdp.send("Input.insertText", { text: ch });
        if (d) await delay(d);
      }
      return reply(res, 200, { ok: true });
    }

    if (method === "POST" && url.pathname === "/fill") {
      const { id, selector, text, timeout = 30000 } = await readJson(req);
      const s = await withSession(id);
      const expr = `(() => { const el = document.querySelector(${JSON.stringify(selector)}); if (!el) throw new Error('not found'); el.focus(); if ('value' in el) { el.value = ${JSON.stringify(text)}; el.dispatchEvent(new Event('input', {bubbles:true})); el.dispatchEvent(new Event('change', {bubbles:true})); } else { el.textContent = ${JSON.stringify(text)}; } return true; })()`;
      const r = await s.cdp.send("Runtime.evaluate", { expression: expr, awaitPromise: true, returnByValue: true });
      return reply(res, 200, { ok: true, result: r.result && r.result.value });
    }

    if (method === "POST" && url.pathname === "/press") {
      const { id, selector = null, key, timeout = 30000 } = await readJson(req);
      const s = await withSession(id);
      if (selector) {
        await s.cdp.send("DOM.enable");
        const doc = await s.cdp.send("DOM.getDocument", { depth: 1 });
        const q = await s.cdp.send("DOM.querySelector", { nodeId: doc.root.nodeId, selector });
        if (q.nodeId) await s.cdp.send("DOM.focus", { nodeId: q.nodeId });
      }
      // Map key names to proper key codes
      const keyCodeMap = {
        'Enter': 13,
        'Return': 13,
        'Tab': 9,
        'Escape': 27,
        'Backspace': 8,
        'Delete': 46,
        'Space': 32
      };
      
      const keyCode = keyCodeMap[key] || key.charCodeAt?.(0) || 0;
      
      await s.cdp.send("Input.dispatchKeyEvent", { 
        type: "keyDown", 
        key,
        windowsVirtualKeyCode: keyCode,
        nativeVirtualKeyCode: keyCode
      });
      await s.cdp.send("Input.dispatchKeyEvent", { 
        type: "keyUp", 
        key,
        windowsVirtualKeyCode: keyCode,
        nativeVirtualKeyCode: keyCode
      });
      return reply(res, 200, { ok: true });
    }

    if (method === "POST" && url.pathname === "/wait-for") {
      const { id, selector, state = "visible", timeout = 30000 } = await readJson(req);
      const s = await withSession(id);
      const start = Date.now();
      const expr = `(${function(sel, st, t0){
        const check = () => {
          const el = document.querySelector(sel);
          if (!el) return st === 'detached' || st === 'hidden' ? true : false;
          const rect = el.getBoundingClientRect();
          const visible = !!(rect.width || rect.height);
          if (st === 'visible') return visible;
          if (st === 'attached') return !!el;
          if (st === 'hidden') return !visible;
          if (st === 'detached') return false; // handled above on null
          return false;
        };
        return new Promise((resolve, reject) => {
          const tick = () => {
            if (check()) return resolve(true);
            if (Date.now() - t0 > 30000) return reject(new Error('timeout'));
            setTimeout(tick, 100);
          };
          tick();
        });
      }})(${JSON.stringify(selector)}, ${JSON.stringify(state)}, ${Date.now()})`;
      await s.cdp.send("Runtime.evaluate", { expression: expr, awaitPromise: true, returnByValue: true });
      return reply(res, 200, { ok: true });
    }

    if (method === "GET" && url.pathname === "/dom") {
      const id = url.searchParams.get("id");
      const prettify = url.searchParams.get("prettify") === "1";
      const s = await withSession(id);
      const r = await s.cdp.send("Runtime.evaluate", { expression: "document.documentElement.outerHTML", returnByValue: true });
      let html = r.result.value || "";
      if (prettify) html = html.replace(/></g, ">\n<");
      return reply(res, 200, { ok: true, html });
    }

    if (method === "GET" && url.pathname === "/text") {
      const id = url.searchParams.get("id");
      const selector = url.searchParams.get("selector");
      const s = await withSession(id);
      let expr = selector ? `(() => { const el = document.querySelector(${JSON.stringify(selector)}); return el ? (el.innerText || '') : ''; })()` : "document.body ? document.body.innerText : ''";
      const r = await s.cdp.send("Runtime.evaluate", { expression: expr, returnByValue: true });
      return reply(res, 200, { ok: true, text: r.result.value || "" });
    }

    if (method === "GET" && url.pathname === "/attr") {
      const id = url.searchParams.get("id");
      const selector = url.searchParams.get("selector");
      const name = url.searchParams.get("name");
      const s = await withSession(id);
      const expr = `(() => { const el = document.querySelector(${JSON.stringify(selector)}); return el ? el.getAttribute(${JSON.stringify(name)}) : null; })()`;
      const r = await s.cdp.send("Runtime.evaluate", { expression: expr, returnByValue: true });
      return reply(res, 200, { ok: true, value: r.result.value });
    }

    if (method === "POST" && url.pathname === "/screenshot") {
      const { id, path: outPath = null, fullPage = false } = await readJson(req);
      const s = await withSession(id);
      if (fullPage) {
        // Expand viewport via Emulation
        const metrics = await s.cdp.send("Page.getLayoutMetrics");
        const { width, height } = metrics.contentSize || { width: 1280, height: 720 };
        await s.cdp.send("Emulation.setDeviceMetricsOverride", { width: Math.ceil(width), height: Math.ceil(height), deviceScaleFactor: 1, mobile: false });
      }
      const shot = await s.cdp.send("Page.captureScreenshot", { fromSurface: true, captureBeyondViewport: true });
      const bufB64 = shot.data;
      if (outPath) {
        fs.writeFileSync(path.resolve(outPath), Buffer.from(bufB64, "base64"));
        return reply(res, 200, { ok: true, path: outPath });
      } else {
        return reply(res, 200, { ok: true, mime: "image/png", base64: bufB64 });
      }
    }

    if (method === "POST" && url.pathname === "/pdf") {
      const { id, path: outPath = null, format = "A4", margin = 10 } = await readJson(req);
      const s = await withSession(id);
      try {
        const pdf = await s.cdp.send("Page.printToPDF", { paperWidth: undefined, paperHeight: undefined, printBackground: true, displayHeaderFooter: false, marginTop: margin/100, marginBottom: margin/100, marginLeft: margin/100, marginRight: margin/100, });
        const b64 = pdf.data;
        if (outPath) {
          fs.writeFileSync(path.resolve(outPath), Buffer.from(b64, "base64"));
          return reply(res, 200, { ok: true, path: outPath });
        } else {
          return reply(res, 200, { ok: true, base64: b64 });
        }
      } catch (e) {
        return reply(res, 500, { ok: false, error: `PDF failed: ${String(e && e.message || e)}` });
      }
    }

    if (method === "GET" && url.pathname === "/cookies") {
      const id = url.searchParams.get("id");
      const s = await withSession(id);
      const r = await s.cdp.send("Network.getCookies", {});
      return reply(res, 200, { ok: true, cookies: r.cookies || [] });
    }

    if (method === "POST" && url.pathname === "/cookies/set") {
      const { id, cookies = [] } = await readJson(req);
      const s = await withSession(id);
      await s.cdp.send("Network.setCookies", { cookies });
      return reply(res, 200, { ok: true });
    }

    if (method === "GET" && url.pathname === "/cookie-get") {
      const id = url.searchParams.get("id");
      const name = url.searchParams.get("name");
      if (!name) return reply(res, 400, { ok: false, error: "Missing cookie name" });
      const s = await withSession(id);
      const r = await s.cdp.send("Network.getCookies", {});
      const cookie = (r.cookies || []).find(c => c.name === name);
      return reply(res, 200, { ok: true, value: cookie ? cookie.value : null, cookie: cookie || null });
    }

    if (method === "POST" && url.pathname === "/cookie-set") {
      const { id, name, value, domain, path = "/" } = await readJson(req);
      if (!name) return reply(res, 400, { ok: false, error: "Missing cookie name" });
      const s = await withSession(id);
      
      // Get current URL to determine domain if not specified
      let cookieDomain = domain;
      if (!cookieDomain) {
        try {
          const urlResult = await s.cdp.send("Runtime.evaluate", { expression: "location.hostname", returnByValue: true });
          cookieDomain = urlResult.result.value;
        } catch {
          cookieDomain = "localhost";
        }
      }
      
      const cookie = {
        name,
        value: String(value),
        domain: cookieDomain,
        path: path || "/",
        httpOnly: false,
        secure: false,
        sameSite: "Lax"
      };
      
      await s.cdp.send("Network.setCookie", cookie);
      return reply(res, 200, { ok: true, cookie });
    }

    if (method === "GET" && url.pathname === "/storage/export") {
      const id = url.searchParams.get("id");
      const s = await withSession(id);
      const data = await s.cdp.send("Runtime.evaluate", { expression: `(() => { const dump=(st)=>{const o={}; for (let i=0;i<st.length;i++){const k=st.key(i); o[k]=st.getItem(k);} return o;}; return {localStorage: dump(window.localStorage), sessionStorage: dump(window.sessionStorage)}; })()`, returnByValue: true });
      return reply(res, 200, { ok: true, ...data.result.value });
    }

    if (method === "POST" && url.pathname === "/storage/import") {
      const { id, data } = await readJson(req);
      const s = await withSession(id);
      await s.cdp.send("Runtime.evaluate", { expression: `(() => { const d=${JSON.stringify(data)}; const l=d.localStorage||{}; const s=d.sessionStorage||{}; Object.entries(l).forEach(([k,v])=>localStorage.setItem(k,v)); Object.entries(s).forEach(([k,v])=>sessionStorage.setItem(k,v)); return true; })()`, awaitPromise: true, returnByValue: true });
      return reply(res, 200, { ok: true });
    }

    if (method === "POST" && url.pathname === "/eval") {
      const { id, code } = await readJson(req);
      const s = await withSession(id);
      const r = await s.cdp.send("Runtime.evaluate", { expression: code, returnByValue: true });
      const response = { ok: true };
      if (r.exceptionDetails) {
        response.ok = false;
        response.error = r.exceptionDetails.exception?.description || r.exceptionDetails.text || 'Unknown error';
      } else if (r.result?.type === 'undefined') {
        response.result = null;
        response.resultType = 'undefined';
      } else {
        response.result = r.result?.value;
      }
      return reply(res, 200, response);
    }

    if (method === "POST" && url.pathname === "/llm") {
      const { id, question, onHtml = false } = await readJson(req);
      
      // Check for OpenAI API key
      const apiKey = process.env.OPENAI_API_KEY;
      if (!apiKey) {
        return reply(res, 400, { ok: false, error: "OPENAI_API_KEY environment variable not set. Please set it to use the llm command." });
      }

      const s = await withSession(id);
      
      let content;
      if (onHtml) {
        // Get full HTML when --on-html flag is used
        const r = await s.cdp.send("Runtime.evaluate", { expression: "document.documentElement.outerHTML", returnByValue: true });
        content = r.result.value || "";
        
        // Proactively truncate if HTML is over 200KB
        const maxSize = 200 * 1024; // 200KB
        if (content.length > maxSize) {
          serverLog(`HTML too large (${content.length} chars). Truncating to ${maxSize} chars`);
          content = content.substring(0, maxSize);
        }
      } else {
        // Default: extract title and body text
        const titleResult = await s.cdp.send("Runtime.evaluate", { 
          expression: "document.title || ''", 
          returnByValue: true 
        });
        const bodyResult = await s.cdp.send("Runtime.evaluate", { 
          expression: "document.body ? document.body.innerText : ''", 
          returnByValue: true 
        });
        
        const title = titleResult.result.value || "";
        const bodyText = bodyResult.result.value || "";
        
        content = `Title: ${title}\n\nPage Text:\n${bodyText}`;
        
        // Truncate body text if too long (keeping title intact)
        const maxSize = 200 * 1024; // 200KB
        if (content.length > maxSize) {
          const titlePart = `Title: ${title}\n\nPage Text:\n`;
          const availableSpace = maxSize - titlePart.length;
          const truncatedBody = bodyText.substring(0, availableSpace);
          content = titlePart + truncatedBody;
          serverLog(`Text content too large. Truncated body text to fit ${maxSize} chars`);
        }
      }
      
      const makeRequest = async (contentToAnalyze) => {
        const prompt = onHtml 
          ? `Here is the HTML of a webpage:

${contentToAnalyze}

Question: ${question}

Please analyze the HTML and answer the question. Be concise and specific.`
          : `Here is information about a webpage:

${contentToAnalyze}

Question: ${question}

Please analyze the page content and answer the question. Be concise and specific.`;

        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [{ role: "user", content: prompt }],
            max_tokens: 500,
            temperature: 0.1
          })
        });

        return response;
      };

      try {
        // First attempt with full content
        let response = await makeRequest(content);

        if (!response.ok) {
          const error = await response.json();
          
          // Check if it's a token limit error
          if (error.error?.message?.includes("maximum context length")) {
            // Extract the max token limit and current tokens from error message
            const match = error.error.message.match(/maximum context length is (\d+) tokens.*resulted in (\d+) tokens/);
            if (match) {
              const maxTokens = parseInt(match[1]);
              const currentTokens = parseInt(match[2]);
              
              // Calculate how much to truncate (90% of the ratio for safety)
              const ratio = maxTokens / currentTokens;
              const safeRatio = ratio * 0.9;
              const truncateLength = Math.floor(content.length * safeRatio);
              
              serverLog(`Token limit exceeded (${currentTokens}/${maxTokens}). Truncating content from ${content.length} to ${truncateLength} chars`);
              
              // Truncate content and try again
              content = content.substring(0, truncateLength);
              response = await makeRequest(content);
            }
          }
          
          if (!response.ok) {
            const retryError = await response.json();
            return reply(res, 500, { ok: false, error: `OpenAI API error: ${retryError.error?.message || response.statusText}` });
          }
        }

        const data = await response.json();
        const answer = data.choices?.[0]?.message?.content || "No response from OpenAI";
        
        return reply(res, 200, { ok: true, answer });
      } catch (e) {
        return reply(res, 500, { ok: false, error: `Failed to call OpenAI API: ${e.message}` });
      }
    }

    return reply(res, 404, { ok: false, error: "route not found" });
  }

  // Bind server
  if (ep.type === "tcp") {
    server.listen(ep.port, ep.host, () => {});
  } else if (ep.type === "uds") {
    try { fs.rmSync(ep.socket); } catch {}
    server.listen(ep.socket, () => {});
  } else if (ep.type === "pipe") {
    server.listen(ep.pipe, () => {});
  }

  process.on("SIGINT", () => process.exit(0));
  process.on("SIGTERM", () => process.exit(0));
}

////////////////////////////////////////////////////////////////////////////////
// Entrypoint
////////////////////////////////////////////////////////////////////////////////
(async function main() {
  const { flags, rest } = parseArgv(process.argv);

  if (flags.server) {
    const ep = flags.endpoint ? JSON.parse(decodeURIComponent(flags.endpoint)) : getEndpoint(flags);
    await serverMain(ep);
    return;
  }

  await clientMain(flags, rest);
})();

